---
layout: post
title: "[알고리즘] 이분 탐색(Binary Search)에 대하여"
---
첫 게시글인 만큼 가벼운 주제로 시작해보고자 한다.  

이분 탐색은 탐색 알고리즘의 한 종류이다.


>### 탐색 알고리즘이란?

주어진 값들 중에서 내가 원하는 값을 찾게 해주는 것이 탐색 알고리즘이다.  

로컬 컴퓨터에서 원하는 파일을 찾거나, 인터넷에서 검색하는 행위 등에 탐색 알고리즘이 쓰이는 만큼, 중요한 알고리즘이라 할 수 있다.

여러 탐색 알고리즘 중 가장 간단한 것은 완전 탐색 알고리즘일 것이다.  
> ### 완전 탐색 알고리즘

모든 원소를 하나씩 보며 내가 찾고 있는 원소인지 확인하는 방법이다.  
예를 들어, 사람 10명의 키가 다음과 같다고 하자.
```C++
175, 181, 172, 158, 155, 169, 183, 188, 165, 181
```
키가 172cm인 사람을 찾고자 할 때, 왼쪽부터 순서대로 보면서 확인하는 방법이 완전 탐색 알고리즘이다. (물론 오른쪽부터 확인해도 상관 없다.)  
C++ 코드로 작성하면 아래와 같다.
```C++
int height[10] =
{ 175, 181, 172, 158, 155, 169, 183, 188, 165, 181 };
int target_height = 172;
for (int i = 0; i < 10; i++)
    if (height[i] == target_height) {
        printf("%d번 째 사람의 키가 %dcm이다.", i,
            target_height);
        break;
    }
```
완전 탐색 알고리즘은 이렇게 정말 간단하지만, 치명적인 단점이 있다.  
바로 시간 복잡도이다.
>#### 시간복잡도란?

알고리즘의 성능을 나타내는 지표로, 주로 big-O표기법을 사용하여 나타낸다.  
O(f(n))의 형태로, n은 입력 데이터의 개수를 의미한다.
  
완전 탐색 알고리즘의 시간 복잡도는 O(n)으로, 데이터 개수에 선형적으로 비례하는 시간이 걸린다.  
즉, 위 예시에서 생각해보면 가장 끝 원소인 181cm를 찾기 위해서는 n=10개의 원소를 모두 탐색해야 한다.  
n=100, 1000, 10000, .. 일 때도 마찬가지로 데이터의 수만큼 탐색해야 하는 경우가 있을 수 있는 것이다.

>### 컴퓨터가 빨라져서 괜찮지 않나?

라는 생각을 할 수 있지만, 컴퓨터 이용자의 수도 늘어났기 때문에, 원활한 응답을 위해서 다량의 쿼리를 짧은 시간 내에 처리할 수 있는 알고리즘이 필요하다.  






